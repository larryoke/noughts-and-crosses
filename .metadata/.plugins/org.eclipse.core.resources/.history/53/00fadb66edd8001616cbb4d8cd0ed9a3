package gameService.service.impl;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.springframework.stereotype.Service;

import gameCommon.Mark;
import gameCommon.PlayResult;
import gameCommon.MarkStatus;
import gameCommon.Player;
import gameCommon.Square;
import gameCommon.domain.Game;
import gameService.domain.GameFactory;
import gameService.service.GameService;

@Service
public class GameServiceImpl implements GameService {

    private static int GAME_NUMBER = 0;

    private Map<Integer, Game> games = new HashMap<Integer, Game>();

    @Override
    public int initialiseNewGame() {
	Game game = GameFactory.create(++GAME_NUMBER);
	games.put(GAME_NUMBER, game);
	return GAME_NUMBER;
    }

    @Override
    public PlayResult processCurrentMark(Mark play) {
	Game game = games.get(play.getGameID());
	Player currentPlayer = play.getCurrentPlayer();
	Square selectedSquare = play.getSelectedSquare();
	if (Player.X.equals(currentPlayer)) {
	    if (game.getxPlays().contains(selectedSquare)) {
		return new PlayResult(MarkStatus.ERROR, null, "This square is already selected");

	    } else {
		game.playX(selectedSquare);
		PlayResult result = processPlay(game, game.getxPlays());
		if (MarkStatus.WIN.equals(result.getPlayStatus())) {
		    game.incrementXPlayerScore();
		    String score = "SCORE: X " + game.getxPlayerScore() + " vs O " + game.getoPlayerScore();
		    result.setScore(score);
		}
		return result;
	    }

	} else if (Player.O.equals(currentPlayer)) {
	    if (game.getoPlays().contains(selectedSquare)) {
		return new PlayResult(MarkStatus.ERROR, null, "This square is already selected");

	    } else {
		game.playO(selectedSquare);
		PlayResult result = processPlay(game, game.getoPlays());
		if (MarkStatus.WIN.equals(result.getPlayStatus())) {
		    game.incrementOPlayerScore();
		    String score = "SCORE: X " + game.getxPlayerScore() + " O " + game.getoPlayerScore();
		    result.setScore(score);
		}
		return result;
	    }
	}
	return null;
    }

    @Override
    public void endGame(int gameID) {
	games.remove(gameID);
    }

    private PlayResult processPlay(Game game, Set<Square> playerSquares) {
	MarkStatus status = processPlayStatus(playerSquares);

	if (MarkStatus.WIN.equals(status) || MarkStatus.DRAW.equals(status)) {
	    game.getoPlays().clear();
	    game.getxPlays().clear();
	    return new PlayResult(status, null, null);

	} else {
	    return new PlayResult(MarkStatus.CONTINUE, null, null);
	}
    }

    private MarkStatus processPlayStatus(Set<Square> playerSquares) {
	if (playerSquares.contains(Square.ONE) && playerSquares.contains(Square.TWO)
		&& playerSquares.contains(Square.TWO)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.FOUR) && playerSquares.contains(Square.FIVE)
		&& playerSquares.contains(Square.SIX)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.SEVEN) && playerSquares.contains(Square.EIGHT)
		&& playerSquares.contains(Square.NINE)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.ONE) && playerSquares.contains(Square.FOUR)
		&& playerSquares.contains(Square.SEVEN)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.TWO) && playerSquares.contains(Square.FIVE)
		&& playerSquares.contains(Square.EIGHT)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.THREE) && playerSquares.contains(Square.SIX)
		&& playerSquares.contains(Square.NINE)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.ONE) && playerSquares.contains(Square.FIVE)
		&& playerSquares.contains(Square.NINE)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.contains(Square.THREE) && playerSquares.contains(Square.FIVE)
		&& playerSquares.contains(Square.SEVEN)) {
	    return MarkStatus.WIN;

	} else if (playerSquares.size() == 5) {
	    return MarkStatus.DRAW;
	}
	return MarkStatus.CONTINUE;
    }

}
